name: Reusable Deployment Workflow

# This is a reusable workflow that can be called by environment-specific workflows
# It contains all the deployment logic, parameterized by environment
#
# Setup Status: âœ… Configured and ready for use
# - GitHub Environments created (dev, stage)
# - All secrets configured (ACR, SSH, Application)
# - Ready for deployment testing
#
# Called by:
# - deploy-dev.yml (deploys to DEV environment)
# - deploy-stage.yml (deploys to STAGE environment)
# - deploy-prod.yml (deploys to PRODUCTION environment)
#
on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment (dev, stage, prod)'
        required: true
        type: string
      image-tag-suffix:
        description: 'Suffix for the latest tag (e.g., dev-latest, stage-latest, prod-latest)'
        required: true
        type: string
      deployment-reason:
        description: 'Reason for deployment (for manual triggers)'
        required: false
        type: string
        default: 'Automated deployment'
      release-version:
        description: 'Release version for production (extracted from branch name)'
        required: false
        type: string
        default: ''
      skip-health-checks:
        description: 'Skip health checks (emergency production deployments only)'
        required: false
        type: boolean
        default: false
      environment-display-name:
        description: 'Display name for the environment (e.g., DEV, STAGE, PRODUCTION)'
        required: false
        type: string
        default: ''
      app-url:
        description: 'Public application URL for display in summary (non-sensitive)'
        required: false
        type: string
        default: ''
      pre-built-image-tag:
        description: 'Use existing image tag instead of building (for approval workflow)'
        required: false
        type: string
        default: ''
    outputs:
      image-tag:
        description: 'The Docker image tag that was deployed'
        value: ${{ jobs.build.outputs.image-tag }}
      deployment-time:
        description: 'Timestamp of the deployment'
        value: ${{ jobs.build.outputs.deployment-time }}
      release-version:
        description: 'The release version (production only)'
        value: ${{ jobs.build.outputs.release-version }}

env:
  NODE_VERSION: '22.x'
  DOCKER_IMAGE_NAME: shiplink-frontend

jobs:
  # ============================================================================
  # JOB 1: BUILD & PUSH DOCKER IMAGE
  # ============================================================================
  build:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: ${{ inputs.environment }} # Need environment access for ACR secrets

    permissions:
      contents: read # Read repository code for building

    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
      deployment-time: ${{ steps.meta.outputs.deployment-time }}
      release-version: ${{ steps.meta.outputs.release-version }}

    steps:
      # ----------------------------------------------------------------------
      # STEP 1: Check if using pre-built image
      # ----------------------------------------------------------------------
      - name: Check for pre-built image
        id: check
        run: |
          PRE_BUILT="${{ inputs.pre-built-image-tag }}"
          if [ -n "$PRE_BUILT" ]; then
            echo "skip-build=true" >> $GITHUB_OUTPUT
            echo "âœ… Using pre-built image: ${PRE_BUILT}"
          else
            echo "skip-build=false" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Building new Docker image"
          fi

      # ----------------------------------------------------------------------
      # STEP 2: Checkout code (only if building)
      # ----------------------------------------------------------------------
      - name: Checkout code
        if: steps.check.outputs.skip-build == 'false'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for better context

      # ----------------------------------------------------------------------
      # STEP 3: Generate deployment metadata
      # ----------------------------------------------------------------------
      - name: Generate deployment metadata
        id: meta
        run: |
          # Use pre-built image tag or create new one
          if [ "${{ steps.check.outputs.skip-build }}" = "true" ]; then
            IMAGE_TAG="${{ inputs.pre-built-image-tag }}"
            echo "ðŸ“¦ Using pre-built image tag: ${IMAGE_TAG}"
          else
            # Create unique image tag using git commit SHA (first 8 chars)
            IMAGE_TAG="${GITHUB_SHA:0:8}"
            echo "ðŸ†• Generated new image tag: ${IMAGE_TAG}"
          fi
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

          # Record deployment timestamp
          DEPLOYMENT_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          echo "deployment-time=${DEPLOYMENT_TIME}" >> $GITHUB_OUTPUT

          # Handle release version for production deployments
          RELEASE_VERSION="${{ inputs.release-version }}"
          if [ -n "$RELEASE_VERSION" ]; then
            echo "release-version=${RELEASE_VERSION}" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Release Version: ${RELEASE_VERSION}"
          else
            echo "release-version=none" >> $GITHUB_OUTPUT
          fi

          # Log deployment info
          echo "ðŸš€ Deployment Information:"
          echo "  - Environment: ${{ inputs.environment }}"
          echo "  - Image Tag: ${IMAGE_TAG}"
          echo "  - Release Version: ${RELEASE_VERSION:-N/A}"
          echo "  - Pre-built: ${{ steps.check.outputs.skip-build }}"
          echo "  - Commit SHA: ${{ github.sha }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Triggered by: ${{ github.actor }}"
          echo "  - Deployment Time: ${DEPLOYMENT_TIME}"
          echo "  - Reason: ${{ inputs.deployment-reason }}"

      # ----------------------------------------------------------------------
      # STEP 4: Login to Azure Container Registry (only if building)
      # Secrets are configured in GitHub Environments (Settings â†’ Environments)
      # ----------------------------------------------------------------------
      - name: Login to Azure Container Registry
        if: steps.check.outputs.skip-build == 'false'
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_REGISTRY_URL }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      # ----------------------------------------------------------------------
      # STEP 5: Set up Docker Buildx (for better caching and multi-platform)
      # ----------------------------------------------------------------------
      - name: Set up Docker Buildx
        if: steps.check.outputs.skip-build == 'false'
        uses: docker/setup-buildx-action@v3

      # ----------------------------------------------------------------------
      # STEP 6: Build Docker image with environment variables (only if building)
      # NOTE: Build args match Azure Pipelines setup (Dockerfile.ci requirements)
      # Secrets are passed here for build process but NOT in final image (multi-stage build)
      # All vars are ALSO passed at runtime for the running container
      # ----------------------------------------------------------------------
      - name: Build and tag Docker image
        if: steps.check.outputs.skip-build == 'false'
        id: docker-build
        run: |
          # Base tags (always applied)
          TAGS="${{ secrets.ACR_REGISTRY_URL }}/${{ env.DOCKER_IMAGE_NAME }}:${{ steps.meta.outputs.image-tag }},${{ secrets.ACR_REGISTRY_URL }}/${{ env.DOCKER_IMAGE_NAME }}:${{ inputs.image-tag-suffix }}"

          # Add release version tag for production deployments
          if [ "${{ inputs.environment }}" = "prod" ] && [ "${{ steps.meta.outputs.release-version }}" != "none" ]; then
            RELEASE_TAG="${{ secrets.ACR_REGISTRY_URL }}/${{ env.DOCKER_IMAGE_NAME }}:release-${{ steps.meta.outputs.release-version }}"
            TAGS="${TAGS},${RELEASE_TAG}"
            echo "ðŸ“¦ Adding production release tag: ${RELEASE_TAG}"
          fi

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸  Image tags: ${TAGS}"

      - name: Build Docker image
        if: steps.check.outputs.skip-build == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.ci
          push: true
          tags: ${{ steps.docker-build.outputs.tags }}
          build-args: |
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            NEXT_PUBLIC_URL=${{ secrets.NEXT_PUBLIC_URL }}
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
            NEXT_PUBLIC_RECAPTCHA_SITE_KEY=${{ secrets.NEXT_PUBLIC_RECAPTCHA_SITE_KEY }}
            NEXT_PUBLIC_SEAMETRIX_KEY=${{ secrets.NEXT_PUBLIC_SEAMETRIX_KEY }}
            NEXT_PUBLIC_SEAMETRIX_API_URL=${{ secrets.NEXT_PUBLIC_SEAMETRIX_API_URL }}
            NEXT_PUBLIC_SEAMETRIX_MAP_KEY=${{ secrets.NEXT_PUBLIC_SEAMETRIX_MAP_KEY }}
            RECAPTCHA_SECRET_KEY=${{ secrets.RECAPTCHA_SECRET_KEY }}
            NEXT_PUBLIC_STRAPI_API_URL=${{ secrets.NEXT_PUBLIC_STRAPI_API_URL }}
            NEXT_PUBLIC_RT_URL=${{ secrets.NEXT_PUBLIC_RT_URL }}
            BACKEND_API_URL=${{ secrets.BACKEND_API_URL }}
            IDENTITY_API_URL=${{ secrets.IDENTITY_API_URL }}
            NEXT_PUBLIC_FILE_API_URL=${{ secrets.NEXT_PUBLIC_FILE_API_URL }}
            NEXT_PUBLIC_ADMIN_URL=${{ secrets.NEXT_PUBLIC_ADMIN_URL }}
            NEXT_PUBLIC_APP_ENV=${{ secrets.NEXT_PUBLIC_APP_ENV }}
            NEXT_PUBLIC_MAINTENANCE_MODE=${{ secrets.NEXT_PUBLIC_MAINTENANCE_MODE }}
            NEXT_PUBLIC_BETA_MODE=${{ secrets.NEXT_PUBLIC_BETA_MODE }}
            NEXT_PUBLIC_ENABLE_MATOMO=${{ secrets.NEXT_PUBLIC_ENABLE_MATOMO }}
            NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY=${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY }}
            NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID=${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID }}
            NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID=${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID }}
            NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY=${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY }}
            NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID=${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID }}
            SEAMETRIX_API_URL=${{ secrets.SEAMETRIX_API_URL }}
            SEAMETRIX_MAP_KEY=${{ secrets.SEAMETRIX_MAP_KEY }}
            IDENTITY_API_CLIENT_ID=${{ secrets.IDENTITY_API_CLIENT_ID }}
            IDENTITY_API_CLIENT_SECRET=${{ secrets.IDENTITY_API_CLIENT_SECRET }}
            IDENTITY_API_GRANT_TYPE=${{ secrets.IDENTITY_API_GRANT_TYPE }}
            IDENTITY_TOKEN_GRANT_TYPE=${{ secrets.IDENTITY_TOKEN_GRANT_TYPE }}
            PREVIEW_SECRET=${{ secrets.PREVIEW_SECRET }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ----------------------------------------------------------------------
      # STEP 7: Verify image was pushed successfully (or using pre-built)
      # ----------------------------------------------------------------------
      - name: Verify Docker image
        run: |
          if [ "${{ steps.check.outputs.skip-build }}" = "true" ]; then
            echo "âœ… Using pre-built Docker image"
            echo "ðŸ“¦ Image Tag: ${{ steps.meta.outputs.image-tag }}"
          else
            echo "âœ… Docker image built and pushed successfully"
            echo "ðŸ“¦ Image: ${{ secrets.ACR_REGISTRY_URL }}/${{ env.DOCKER_IMAGE_NAME }}:${{ steps.meta.outputs.image-tag }}"
          fi

  # ============================================================================
  # JOB 2: DEPLOY TO SERVER
  # ============================================================================
  deploy:
    name: Deploy to ${{ inputs.environment }} Server
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: build
    environment: ${{ inputs.environment }}

    permissions:
      contents: read

    steps:
      # ----------------------------------------------------------------------
      # STEP 1: Setup SSH connection
      # SSH credentials are configured in GitHub Environments per environment
      # Supports both SSH key-based and password authentication
      # ----------------------------------------------------------------------
      - name: Setup SSH connection
        run: |
          # Determine authentication method once (avoid redundant checks)
          USE_SSH_KEY="${{ secrets.SSH_PRIVATE_KEY != '' }}"

          mkdir -p ~/.ssh

          # Add SSH host to known_hosts to avoid prompt
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

          # Configure authentication based on method
          if [ "$USE_SSH_KEY" = "true" ]; then
            echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            echo "âœ… SSH key configured"
          else
            # Install sshpass for password authentication
            sudo apt-get update -qq
            sudo apt-get install -y sshpass
            echo "âœ… SSH password authentication configured"
          fi

      # ----------------------------------------------------------------------
      # STEP 2: Deploy to server via SSH
      # This is where the magic happens! ðŸŽ©
      # ----------------------------------------------------------------------
      - name: Deploy container to server
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
          REGISTRY_URL: ${{ secrets.ACR_REGISTRY_URL }}
          ENVIRONMENT: ${{ inputs.environment }}
          # Use SSHPASS environment variable for security (not exposed in process list)
          SSHPASS: ${{ secrets.SSH_PASSWORD }}
        run: |
          # Determine authentication method once (consistent with setup step)
          USE_SSH_KEY="${{ secrets.SSH_PRIVATE_KEY != '' }}"

          # Build SSH command based on authentication method
          if [ "$USE_SSH_KEY" = "true" ]; then
            # SSH key authentication
            SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.SSH_PORT || 22 }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}"
          else
            # Password authentication using sshpass with environment variable (more secure)
            SSH_CMD="sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.SSH_PORT || 22 }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}"
          fi

          # Execute deployment script on remote server
          $SSH_CMD << 'ENDSSH'
          set -e  # Exit on any error

          # Configuration
          CONTAINER_NAME="${{ env.DOCKER_IMAGE_NAME }}"
          NEW_IMAGE="${{ env.REGISTRY_URL }}/${{ env.DOCKER_IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"

          echo "=================================================="
          echo "ðŸš€ Starting deployment to $(echo '${{ env.ENVIRONMENT }}' | tr '[:lower:]' '[:upper:]') environment"
          echo "=================================================="
          echo "Container: ${CONTAINER_NAME}"
          echo "New Image: ${NEW_IMAGE}"
          echo ""

          # ------------------------------------------------------
          # Login to Azure Container Registry from server
          # ------------------------------------------------------
          echo "ðŸ“¦ Logging in to container registry..."
          echo "${{ secrets.ACR_PASSWORD }}" | docker login \
            ${{ secrets.ACR_REGISTRY_URL }} \
            --username ${{ secrets.ACR_USERNAME }} \
            --password-stdin

          # ------------------------------------------------------
          # Pull new image
          # ------------------------------------------------------
          echo "â¬‡ï¸  Pulling new image..."
          docker pull "${NEW_IMAGE}"

          # ------------------------------------------------------
          # Check if old container exists and tag its image for rollback
          # ------------------------------------------------------
          if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo "ðŸ“¦ Found existing container, preparing for rollback capability..."
            OLD_IMAGE=$(docker inspect --format='{{.Image}}' "${CONTAINER_NAME}" 2>/dev/null || echo "none")
            
            if [ "${OLD_IMAGE}" != "none" ]; then
              docker tag "${OLD_IMAGE}" "${CONTAINER_NAME}-previous" 2>/dev/null || true
              echo "âœ… Tagged old image as '${CONTAINER_NAME}-previous' for rollback"
            fi
            
            echo "ðŸ›‘ Stopping old container..."
            docker stop "${CONTAINER_NAME}" 2>/dev/null || true
            
            echo "ðŸ—‘ï¸  Removing old container..."
            docker rm "${CONTAINER_NAME}" 2>/dev/null || true
          else
            echo "â„¹ï¸  No existing container found (first deployment or clean slate)"
          fi

          # ------------------------------------------------------
          # Start new container with all runtime environment variables
          # IMPORTANT: Secrets are passed here, NOT in Docker build!
          # ------------------------------------------------------
          echo "ðŸš€ Starting new container..."
          docker run -d \
            --name "${CONTAINER_NAME}" \
            --restart always \
            -p 3000:3000 \
            -e NEXT_PUBLIC_URL="${{ secrets.NEXT_PUBLIC_URL }}" \
            -e NEXT_PUBLIC_API_URL="${{ secrets.NEXT_PUBLIC_API_URL }}" \
            -e NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}" \
            -e NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}" \
            -e NEXT_PUBLIC_RECAPTCHA_SITE_KEY="${{ secrets.NEXT_PUBLIC_RECAPTCHA_SITE_KEY }}" \
            -e RECAPTCHA_SECRET_KEY="${{ secrets.RECAPTCHA_SECRET_KEY }}" \
            -e NEXT_PUBLIC_SEAMETRIX_KEY="${{ secrets.NEXT_PUBLIC_SEAMETRIX_KEY }}" \
            -e NEXT_PUBLIC_SEAMETRIX_MAP_KEY="${{ secrets.NEXT_PUBLIC_SEAMETRIX_MAP_KEY }}" \
            -e SEAMETRIX_MAP_KEY="${{ secrets.SEAMETRIX_MAP_KEY }}" \
            -e NEXT_PUBLIC_SEAMETRIX_API_URL="${{ secrets.NEXT_PUBLIC_SEAMETRIX_API_URL }}" \
            -e SEAMETRIX_API_URL="${{ secrets.SEAMETRIX_API_URL }}" \
            -e NEXT_PUBLIC_STRAPI_API_URL="${{ secrets.NEXT_PUBLIC_STRAPI_API_URL }}" \
            -e NEXT_PUBLIC_RT_URL="${{ secrets.NEXT_PUBLIC_RT_URL }}" \
            -e NEXT_PUBLIC_FILE_API_URL="${{ secrets.NEXT_PUBLIC_FILE_API_URL }}" \
            -e BACKEND_API_URL="${{ secrets.BACKEND_API_URL }}" \
            -e IDENTITY_API_URL="${{ secrets.IDENTITY_API_URL }}" \
            -e IDENTITY_API_CLIENT_ID="${{ secrets.IDENTITY_API_CLIENT_ID }}" \
            -e IDENTITY_API_CLIENT_SECRET="${{ secrets.IDENTITY_API_CLIENT_SECRET }}" \
            -e IDENTITY_API_GRANT_TYPE="${{ secrets.IDENTITY_API_GRANT_TYPE }}" \
            -e IDENTITY_TOKEN_GRANT_TYPE="${{ secrets.IDENTITY_TOKEN_GRANT_TYPE }}" \
            -e PREVIEW_SECRET="${{ secrets.PREVIEW_SECRET }}" \
            -e APP_ENV="${{ secrets.APP_ENV }}" \
            -e IDENTITY_NEW_RELIC_APP_NAME="${{ secrets.IDENTITY_NEW_RELIC_APP_NAME }}" \
            -e IDENTITY_NEW_RELIC_LICENSE_KEY="${{ secrets.IDENTITY_NEW_RELIC_LICENSE_KEY }}" \
            -e OTEL_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_EXPORTER_OTLP_ENDPOINT }}" \
            -e OTEL_METRIC_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_METRIC_EXPORTER_OTLP_ENDPOINT }}" \
            -e NEXT_PUBLIC_MAINTENANCE_MODE="${{ secrets.NEXT_PUBLIC_MAINTENANCE_MODE }}" \
            -e NEXT_PUBLIC_BETA_MODE="${{ secrets.NEXT_PUBLIC_BETA_MODE }}" \
            -e NEXT_PUBLIC_APP_ENV="${{ secrets.NEXT_PUBLIC_APP_ENV }}" \
            -e NEXT_PUBLIC_ENABLE_MATOMO="${{ secrets.NEXT_PUBLIC_ENABLE_MATOMO }}" \
            -e NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY }}" \
            -e NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID }}" \
            -e NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID }}" \
            -e NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY }}" \
            -e NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID }}" \
            -e NEXT_PUBLIC_ADMIN_URL="${{ secrets.NEXT_PUBLIC_ADMIN_URL }}" \
            "${NEW_IMAGE}"

          # ------------------------------------------------------
          # Wait for container to start and verify it's running
          # ------------------------------------------------------
          echo ""
          echo "â³ Waiting 30 seconds for application to start..."
          sleep 30

          # Check if container is still running
          if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo ""
            echo "=================================================="
            echo "âœ… DEPLOYMENT SUCCESSFUL!"
            echo "=================================================="
            echo "Container Status:"
            docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            echo "Recent Logs:"
            docker logs --tail 20 "${CONTAINER_NAME}" 2>&1 || true
            
          else
            echo ""
            echo "=================================================="
            echo "âŒ DEPLOYMENT FAILED - Container not running!"
            echo "=================================================="
            echo ""
            echo "Container logs:"
            docker logs "${CONTAINER_NAME}" 2>&1 || true
            echo ""
            
            # Attempt automatic rollback
            if docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "${CONTAINER_NAME}-previous"; then
              echo "ðŸ”„ Attempting automatic rollback..."
              docker rm -f "${CONTAINER_NAME}" 2>/dev/null || true
              
              # Start previous version
              docker run -d \
                --name "${CONTAINER_NAME}" \
                --restart always \
                -p 3000:3000 \
                -e NEXT_PUBLIC_URL="${{ secrets.NEXT_PUBLIC_URL }}" \
                -e NEXT_PUBLIC_API_URL="${{ secrets.NEXT_PUBLIC_API_URL }}" \
                -e NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}" \
                -e NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}" \
                -e NEXT_PUBLIC_RECAPTCHA_SITE_KEY="${{ secrets.NEXT_PUBLIC_RECAPTCHA_SITE_KEY }}" \
                -e RECAPTCHA_SECRET_KEY="${{ secrets.RECAPTCHA_SECRET_KEY }}" \
                -e NEXT_PUBLIC_SEAMETRIX_KEY="${{ secrets.NEXT_PUBLIC_SEAMETRIX_KEY }}" \
                -e NEXT_PUBLIC_SEAMETRIX_MAP_KEY="${{ secrets.NEXT_PUBLIC_SEAMETRIX_MAP_KEY }}" \
                -e SEAMETRIX_MAP_KEY="${{ secrets.SEAMETRIX_MAP_KEY }}" \
                -e NEXT_PUBLIC_SEAMETRIX_API_URL="${{ secrets.NEXT_PUBLIC_SEAMETRIX_API_URL }}" \
                -e SEAMETRIX_API_URL="${{ secrets.SEAMETRIX_API_URL }}" \
                -e NEXT_PUBLIC_STRAPI_API_URL="${{ secrets.NEXT_PUBLIC_STRAPI_API_URL }}" \
                -e NEXT_PUBLIC_RT_URL="${{ secrets.NEXT_PUBLIC_RT_URL }}" \
                -e NEXT_PUBLIC_FILE_API_URL="${{ secrets.NEXT_PUBLIC_FILE_API_URL }}" \
                -e BACKEND_API_URL="${{ secrets.BACKEND_API_URL }}" \
                -e IDENTITY_API_URL="${{ secrets.IDENTITY_API_URL }}" \
                -e IDENTITY_API_CLIENT_ID="${{ secrets.IDENTITY_API_CLIENT_ID }}" \
                -e IDENTITY_API_CLIENT_SECRET="${{ secrets.IDENTITY_API_CLIENT_SECRET }}" \
                -e IDENTITY_API_GRANT_TYPE="${{ secrets.IDENTITY_API_GRANT_TYPE }}" \
                -e IDENTITY_TOKEN_GRANT_TYPE="${{ secrets.IDENTITY_TOKEN_GRANT_TYPE }}" \
                -e PREVIEW_SECRET="${{ secrets.PREVIEW_SECRET }}" \
                -e APP_ENV="${{ secrets.APP_ENV }}" \
                -e IDENTITY_NEW_RELIC_APP_NAME="${{ secrets.IDENTITY_NEW_RELIC_APP_NAME }}" \
                -e IDENTITY_NEW_RELIC_LICENSE_KEY="${{ secrets.IDENTITY_NEW_RELIC_LICENSE_KEY }}" \
                -e OTEL_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_EXPORTER_OTLP_ENDPOINT }}" \
                -e OTEL_METRIC_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_METRIC_EXPORTER_OTLP_ENDPOINT }}" \
                -e NEXT_PUBLIC_MAINTENANCE_MODE="${{ secrets.NEXT_PUBLIC_MAINTENANCE_MODE }}" \
                -e NEXT_PUBLIC_BETA_MODE="${{ secrets.NEXT_PUBLIC_BETA_MODE }}" \
                -e NEXT_PUBLIC_APP_ENV="${{ secrets.NEXT_PUBLIC_APP_ENV }}" \
                -e NEXT_PUBLIC_ENABLE_MATOMO="${{ secrets.NEXT_PUBLIC_ENABLE_MATOMO }}" \
                -e NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY }}" \
                -e NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID }}" \
                -e NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID }}" \
                -e NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY }}" \
                -e NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID }}" \
                -e NEXT_PUBLIC_ADMIN_URL="${{ secrets.NEXT_PUBLIC_ADMIN_URL }}" \
                "${CONTAINER_NAME}-previous"
              
              sleep 10
              if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
                echo "âœ… Rollback successful - previous version restored"
              else
                echo "âŒ Rollback failed - manual intervention required"
              fi
            fi
            
            exit 1
          fi

          # ------------------------------------------------------
          # Cleanup old images to save disk space
          # ------------------------------------------------------
          echo ""
          echo "ðŸ§¹ Cleaning up old images..."
          docker image prune -a -f --filter "until=72h" 2>/dev/null || true
          docker builder prune -a -f 2>/dev/null || true

          echo ""
          echo "=================================================="
          echo "ðŸŽ‰ Deployment completed successfully!"
          echo "Environment: $(echo '${{ env.ENVIRONMENT }}' | tr '[:lower:]' '[:upper:]')"
          echo "Image: ${NEW_IMAGE}"
          echo "Deployed at: ${{ needs.build.outputs.deployment-time }}"
          echo "Deployed by: ${{ github.actor }}"
          echo "=================================================="

          ENDSSH

      # ----------------------------------------------------------------------
      # STEP 3: Deployment summary
      # ----------------------------------------------------------------------
      - name: Generate deployment summary
        if: always()
        env:
          APP_URL_FROM_SECRET: ${{ secrets.NEXT_PUBLIC_URL }}
        run: |
          # Use provided display name or default to uppercase environment name
          if [ -n "${{ inputs.environment-display-name }}" ]; then
            ENV_DISPLAY="${{ inputs.environment-display-name }}"
          else
            ENV_DISPLAY=$(echo "${{ inputs.environment }}" | tr '[:lower:]' '[:upper:]')
          fi

          # Use provided app URL, fallback to secret, or indicate it's configured
          if [ -n "${{ inputs.app-url }}" ]; then
            APP_URL="${{ inputs.app-url }}"
          elif [ -n "${APP_URL_FROM_SECRET}" ]; then
            APP_URL="${APP_URL_FROM_SECRET}"
          else
            APP_URL="Configured in environment"
          fi

          echo "# ðŸš€ Deployment Summary - ${ENV_DISPLAY} Environment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${ENV_DISPLAY} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | \`${{ needs.build.outputs.image-tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit SHA** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployed By** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployment Time** | ${{ needs.build.outputs.deployment-time }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Reason** | ${{ inputs.deployment-reason }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" = "success" ]; then
            echo "## âœ… Status: Successful" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The application has been successfully deployed to the ${ENV_DISPLAY} environment." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸŒ **Access URL:** ${APP_URL}" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Status: Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "If automatic rollback occurred, the previous version should be running." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“– [View full workflow run for ${ENV_DISPLAY}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # JOB 3: PRODUCTION HEALTH CHECKS (Production Only)
  # ============================================================================
  health-check:
    name: Production Health Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy
    # Only run for production environment and when health checks are not skipped
    if: inputs.environment == 'prod' && inputs.skip-health-checks == false
    environment: ${{ inputs.environment }}

    permissions:
      contents: read

    steps:
      - name: Wait for application stabilization
        run: |
          echo "â³ Waiting 60 seconds for application to fully stabilize..."
          echo "This ensures all services are properly initialized before health checks"
          sleep 60

      - name: Run health checks
        id: health
        env:
          APP_URL: ${{ secrets.NEXT_PUBLIC_URL }}
        run: |
          echo "ðŸ¥ Starting production health checks..."
          echo ""

          FAILED_CHECKS=0
          TOTAL_CHECKS=0

          # Function to perform health check with retries
          check_endpoint() {
            local name="$1"
            local url="$2"
            local expected_status="$3"
            local max_retries=2
            local retry_delay=5
            
            TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸ“ Testing: $name"
            echo "ðŸ”— URL: $url"
            echo "âœ“ Expected: HTTP $expected_status"
            echo ""
            
            for attempt in $(seq 1 $((max_retries + 1))); do
              if [ $attempt -gt 1 ]; then
                echo "ðŸ”„ Retry attempt $((attempt - 1))/$max_retries after ${retry_delay}s..."
                sleep $retry_delay
              fi
              
              # Perform curl request with timeout
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 --connect-timeout 10 "$url" 2>/dev/null || echo "000")
              
              if [ "$HTTP_CODE" = "$expected_status" ]; then
                echo "âœ… PASS - Received HTTP $HTTP_CODE"
                echo ""
                return 0
              else
                echo "âš ï¸  Received HTTP $HTTP_CODE (expected $expected_status)"
              fi
            done
            
            echo "âŒ FAIL - Health check failed after $max_retries retries"
            echo ""
            FAILED_CHECKS=$((FAILED_CHECKS + 1))
            return 1
          }

          # ============================================================
          # HEALTH CHECK 1: Home Page
          # ============================================================
          check_endpoint "Home Page" "${APP_URL}/" "200"

          # ============================================================
          # HEALTH CHECK 2: API Health Endpoint
          # ============================================================
          check_endpoint "API Health" "${APP_URL}/api/health" "200"

          # ============================================================
          # HEALTH CHECK 3: Protected Authentication Endpoint
          # ============================================================
          # 401 is expected for unauthenticated requests (means service is working)
          check_endpoint "Account Info (Protected)" "${APP_URL}/api/account/info" "401"

          # ============================================================
          # Summary
          # ============================================================
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ðŸ“Š Health Check Summary:"
          echo "  - Total Checks: ${TOTAL_CHECKS}"
          echo "  - Passed: $((TOTAL_CHECKS - FAILED_CHECKS))"
          echo "  - Failed: ${FAILED_CHECKS}"
          echo ""

          # Save results for next steps
          echo "failed-checks=${FAILED_CHECKS}" >> $GITHUB_OUTPUT
          echo "total-checks=${TOTAL_CHECKS}" >> $GITHUB_OUTPUT

          if [ $FAILED_CHECKS -gt 0 ]; then
            echo "âŒ Health checks FAILED"
            exit 1
          else
            echo "âœ… All health checks PASSED"
            exit 0
          fi

      - name: Rollback on health check failure
        if: failure()
        env:
          SSHPASS: ${{ secrets.SSH_PASSWORD }}
        run: |
          echo "ðŸš¨ HEALTH CHECKS FAILED - Initiating automatic rollback"
          echo ""

          # Determine authentication method
          USE_SSH_KEY="${{ secrets.SSH_PRIVATE_KEY != '' }}"

          # Setup SSH
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

          if [ "$USE_SSH_KEY" = "true" ]; then
            echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.SSH_PORT || 22 }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}"
          else
            sudo apt-get update -qq && sudo apt-get install -y sshpass
            SSH_CMD="sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.SSH_PORT || 22 }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}"
          fi

          # Execute rollback on server
          $SSH_CMD << 'ENDSSH'
          set -e

          CONTAINER_NAME="${{ env.DOCKER_IMAGE_NAME }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ”„ AUTOMATIC ROLLBACK INITIATED"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          if docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "${CONTAINER_NAME}-previous"; then
            echo "ðŸ“¦ Previous image found, rolling back..."
            
            # Stop and remove failed container
            docker stop "${CONTAINER_NAME}" 2>/dev/null || true
            docker rm "${CONTAINER_NAME}" 2>/dev/null || true
            
            # Start previous version with all environment variables
            docker run -d \
              --name "${CONTAINER_NAME}" \
              --restart always \
              -p 3000:3000 \
              -e NEXT_PUBLIC_URL="${{ secrets.NEXT_PUBLIC_URL }}" \
              -e NEXT_PUBLIC_API_URL="${{ secrets.NEXT_PUBLIC_API_URL }}" \
              -e NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}" \
              -e NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}" \
              -e NEXT_PUBLIC_RECAPTCHA_SITE_KEY="${{ secrets.NEXT_PUBLIC_RECAPTCHA_SITE_KEY }}" \
              -e RECAPTCHA_SECRET_KEY="${{ secrets.RECAPTCHA_SECRET_KEY }}" \
              -e NEXT_PUBLIC_SEAMETRIX_KEY="${{ secrets.NEXT_PUBLIC_SEAMETRIX_KEY }}" \
              -e NEXT_PUBLIC_SEAMETRIX_MAP_KEY="${{ secrets.NEXT_PUBLIC_SEAMETRIX_MAP_KEY }}" \
              -e SEAMETRIX_MAP_KEY="${{ secrets.SEAMETRIX_MAP_KEY }}" \
              -e NEXT_PUBLIC_SEAMETRIX_API_URL="${{ secrets.NEXT_PUBLIC_SEAMETRIX_API_URL }}" \
              -e SEAMETRIX_API_URL="${{ secrets.SEAMETRIX_API_URL }}" \
              -e NEXT_PUBLIC_STRAPI_API_URL="${{ secrets.NEXT_PUBLIC_STRAPI_API_URL }}" \
              -e NEXT_PUBLIC_RT_URL="${{ secrets.NEXT_PUBLIC_RT_URL }}" \
              -e NEXT_PUBLIC_FILE_API_URL="${{ secrets.NEXT_PUBLIC_FILE_API_URL }}" \
              -e BACKEND_API_URL="${{ secrets.BACKEND_API_URL }}" \
              -e IDENTITY_API_URL="${{ secrets.IDENTITY_API_URL }}" \
              -e IDENTITY_API_CLIENT_ID="${{ secrets.IDENTITY_API_CLIENT_ID }}" \
              -e IDENTITY_API_CLIENT_SECRET="${{ secrets.IDENTITY_API_CLIENT_SECRET }}" \
              -e IDENTITY_API_GRANT_TYPE="${{ secrets.IDENTITY_API_GRANT_TYPE }}" \
              -e IDENTITY_TOKEN_GRANT_TYPE="${{ secrets.IDENTITY_TOKEN_GRANT_TYPE }}" \
              -e PREVIEW_SECRET="${{ secrets.PREVIEW_SECRET }}" \
              -e APP_ENV="${{ secrets.APP_ENV }}" \
              -e IDENTITY_NEW_RELIC_APP_NAME="${{ secrets.IDENTITY_NEW_RELIC_APP_NAME }}" \
              -e IDENTITY_NEW_RELIC_LICENSE_KEY="${{ secrets.IDENTITY_NEW_RELIC_LICENSE_KEY }}" \
              -e OTEL_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_EXPORTER_OTLP_ENDPOINT }}" \
              -e OTEL_METRIC_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_METRIC_EXPORTER_OTLP_ENDPOINT }}" \
              -e NEXT_PUBLIC_MAINTENANCE_MODE="${{ secrets.NEXT_PUBLIC_MAINTENANCE_MODE }}" \
              -e NEXT_PUBLIC_BETA_MODE="${{ secrets.NEXT_PUBLIC_BETA_MODE }}" \
              -e NEXT_PUBLIC_APP_ENV="${{ secrets.NEXT_PUBLIC_APP_ENV }}" \
              -e NEXT_PUBLIC_ENABLE_MATOMO="${{ secrets.NEXT_PUBLIC_ENABLE_MATOMO }}" \
              -e NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_LICENSE_KEY }}" \
              -e NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_APP_ID }}" \
              -e NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_AGENT_ID }}" \
              -e NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_TRUST_KEY }}" \
              -e NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID="${{ secrets.NEXT_PUBLIC_NEW_RELIC_BROWSER_ACCOUNT_ID }}" \
              -e NEXT_PUBLIC_ADMIN_URL="${{ secrets.NEXT_PUBLIC_ADMIN_URL }}" \
              "${CONTAINER_NAME}-previous"
            
            echo ""
            echo "â³ Waiting 15 seconds for rollback container to start..."
            sleep 15
            
            if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              echo ""
              echo "âœ… ROLLBACK SUCCESSFUL"
              echo "Previous version has been restored"
              echo ""
              docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            else
              echo ""
              echo "âŒ ROLLBACK FAILED"
              echo "Manual intervention required immediately!"
              exit 1
            fi
          else
            echo "âŒ No previous image available for rollback"
            echo "Manual intervention required immediately!"
            exit 1
          fi
          ENDSSH

      - name: Generate health check summary
        if: always()
        run: |
          echo "# ðŸ¥ Production Health Check Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.health.outcome }}" = "success" ]; then
            echo "## âœ… All Health Checks Passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Total Checks:** ${{ steps.health.outputs.total-checks || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
            echo "**Failed Checks:** 0" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸŽ‰ Production deployment verified and healthy!" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Health Checks Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Total Checks:** ${{ steps.health.outputs.total-checks || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
            echo "**Failed Checks:** ${{ steps.health.outputs.failed-checks || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸš¨ **Automatic rollback has been initiated**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Action Required:" >> $GITHUB_STEP_SUMMARY
            echo "1. Review the health check logs above" >> $GITHUB_STEP_SUMMARY
            echo "2. Verify rollback was successful" >> $GITHUB_STEP_SUMMARY
            echo "3. Investigate the root cause" >> $GITHUB_STEP_SUMMARY
            echo "4. Fix issues before attempting redeployment" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Endpoints Tested:" >> $GITHUB_STEP_SUMMARY
          echo "- Home Page (\`/\`) - 200 OK" >> $GITHUB_STEP_SUMMARY
          echo "- API Health Endpoint (\`/api/health\`) - 200 OK" >> $GITHUB_STEP_SUMMARY
          echo "- Protected Authentication (\`/api/account/info\`) - 401 Unauthorized" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”— [View deployment details for PRODUCTION](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
