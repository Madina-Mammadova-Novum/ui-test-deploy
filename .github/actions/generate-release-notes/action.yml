name: Generate Release Notes
description: Generates release notes with changelog, contributors, and version tag for GitHub Releases

inputs:
  release-version:
    description: 'Release version from branch name (e.g., 20251023-1)'
    required: true
  image-tag:
    description: 'Docker image tag (short SHA)'
    required: true
  source-branch:
    description: 'Source branch name (e.g., release/20251023-1)'
    required: false
    default: ''
  github-token:
    description: 'GitHub token for API access (automatically provided in Actions)'
    required: false
    default: ${{ github.token }}

outputs:
  tag_name:
    description: 'Generated tag name (e.g., v2025.10.23.1054-f9b4949)'
    value: ${{ steps.generate.outputs.tag_name }}
  release_notes:
    description: 'Generated release notes in markdown format'
    value: ${{ steps.generate.outputs.release_notes }}
  changelog_url:
    description: 'GitHub compare URL for full changelog'
    value: ${{ steps.generate.outputs.changelog_url }}
  previous_tag:
    description: 'Previous release tag (if found)'
    value: ${{ steps.generate.outputs.previous_tag }}

runs:
  using: composite
  steps:
    - name: Generate release metadata
      id: generate
      shell: bash
      run: |
        set -e

        echo "ðŸ·ï¸  Generating release metadata..."
        echo ""

        # ================================================================
        # 1. GENERATE TAG NAME (Match backend format exactly)
        # ================================================================
        # Format: v{YYYY}.{MM}.{DD}.{HHMM}-{SHA8}
        # Example: v2025.10.23.1054-f9b4949

        TIMESTAMP=$(date -u +"%Y.%m.%d.%H%M")
        SHORT_SHA="${{ inputs.image-tag }}"
        TAG_NAME="v${TIMESTAMP}-${SHORT_SHA}"

        echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
        echo "âœ… Generated tag: ${TAG_NAME}"
        echo ""

        # ================================================================
        # 2. FIND PREVIOUS RELEASE TAG
        # ================================================================

        PREV_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD^ 2>/dev/null || echo "")

        if [ -z "$PREV_TAG" ]; then
          echo "â„¹ï¸  No previous release tag found (first release)"
          PREV_TAG="NONE"
          COMPARE_RANGE=""
        else
          echo "âœ… Previous release: ${PREV_TAG}"
          COMPARE_RANGE="${PREV_TAG}..HEAD"
        fi

        echo "previous_tag=${PREV_TAG}" >> $GITHUB_OUTPUT
        echo ""

        # ================================================================
        # 3. GENERATE CHANGELOG URL
        # ================================================================

        if [ "$PREV_TAG" != "NONE" ]; then
          CHANGELOG_URL="https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG_NAME}"
          echo "changelog_url=${CHANGELOG_URL}" >> $GITHUB_OUTPUT
          echo "ðŸ”— Changelog URL: ${CHANGELOG_URL}"
        else
          CHANGELOG_URL="https://github.com/${{ github.repository }}/commits/${TAG_NAME}"
          echo "changelog_url=${CHANGELOG_URL}" >> $GITHUB_OUTPUT
          echo "ðŸ”— Commits URL: ${CHANGELOG_URL}"
        fi
        echo ""

        # ================================================================
        # 4. EXTRACT COMMITS
        # ================================================================

        echo "ðŸ“ Extracting commits..."

        # Get commits between previous tag and HEAD (or all commits if first release)
        # Format: SHA|Subject|Author Name|Author Email|PR Number
        if [ "$PREV_TAG" != "NONE" ]; then
          COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"%h|%s|%an|%ae" --no-merges)
        else
          # For first release, get last 50 commits (reasonable default)
          COMMITS=$(git log -50 --pretty=format:"%h|%s|%an|%ae" --no-merges)
        fi

        # ================================================================
        # 5. PARSE COMMITS BY CONVENTIONAL COMMIT TYPE
        # ================================================================

        echo "ðŸ” Parsing commits by type..."

        # Initialize arrays
        declare -a FIXES
        declare -a FEATURES
        declare -a DOCS
        declare -a REFACTORS
        declare -a STYLES
        declare -a TESTS
        declare -a CHORES
        declare -a OTHERS
        declare -A CONTRIBUTORS

        # Define regex patterns as variables to avoid parsing issues
        CONVENTIONAL_COMMIT_PATTERN='^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(([^)]+)\))?: '
        PR_PATTERN='#([0-9]+)'
        GITHUB_EMAIL_PATTERN='^([^@]+)@users\.noreply\.github\.com$'
        GITHUB_EMAIL_NUMERIC_PATTERN='^[0-9]+\+([^@]+)@users\.noreply\.github\.com$'

        # Cache for GitHub usernames to avoid multiple API calls
        declare -A USERNAME_CACHE
        declare -A PR_AUTHOR_CACHE

        # Helper function to validate API responses
        validate_api_response() {
          local response="$1"
          local api_name="$2"
          
          if [ -z "$response" ]; then
            echo "âš ï¸  Warning: Empty response from ${api_name} API" >&2
            return 1
          fi
          
          # Check for GitHub API error responses
          if echo "$response" | grep -q '"message".*"Not Found"'; then
            return 1
          fi
          
          if echo "$response" | grep -q '"message".*"rate limit"'; then
            echo "âš ï¸  Warning: GitHub API rate limit exceeded for ${api_name}" >&2
            return 1
          fi
          
          if echo "$response" | grep -q '"message".*"API rate limit"'; then
            echo "âš ï¸  Warning: GitHub API rate limit exceeded for ${api_name}" >&2
            return 1
          fi
          
          return 0
        }

        # Helper function to get GitHub username from commit SHA
        get_github_username_from_commit() {
          local commit_sha="$1"
          local author_email="$2"
          local author_name="$3"
          
          # Check cache first
          local cache_key="${author_email}|${author_name}"
          if [ -n "${USERNAME_CACHE[$cache_key]}" ]; then
            echo "${USERNAME_CACHE[$cache_key]}"
            return
          fi
          
          # Try to get GitHub username from commit API
          local github_username=""
          # Use the provided GITHUB_TOKEN input
          if [ -n "${{ inputs.github-token }}" ]; then
            local api_response=$(curl -s -H "Authorization: token ${{ inputs.github-token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/commits/${commit_sha}" 2>/dev/null || echo "")
            
            if validate_api_response "$api_response" "commit"; then
              # Extract author.login from the commit API response using jq (more reliable)
              if command -v jq >/dev/null 2>&1; then
                github_username=$(echo "$api_response" | jq -r '.author.login // .committer.login // empty' 2>/dev/null || echo "")
              else
                # Fallback: use sed/grep if jq is not available
                github_username=$(echo "$api_response" | sed -n 's/.*"author"[^}]*"login"[^"]*"\([^"]*\)".*/\1/p' | head -1 || echo "")
                if [ -z "$github_username" ]; then
                  github_username=$(echo "$api_response" | sed -n 's/.*"committer"[^}]*"login"[^"]*"\([^"]*\)".*/\1/p' | head -1 || echo "")
                fi
              fi
            fi
          fi
          
          # Cache the result (even if empty, to avoid repeated API calls)
          USERNAME_CACHE["$cache_key"]="$github_username"
          echo "$github_username"
        }

        # Helper to get PR author username as a fallback when commit lookup fails
        get_pr_author_username() {
          local pr_number="$1"
          
          # Return cached value when available
          if [ -n "${PR_AUTHOR_CACHE[$pr_number]+_}" ]; then
            echo "${PR_AUTHOR_CACHE[$pr_number]}"
            return
          fi

          local pr_author_username=""

          if [ -n "$pr_number" ] && [ -n "${{ inputs.github-token }}" ]; then
            local pr_response=$(curl -s -H "Authorization: token ${{ inputs.github-token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/${pr_number}" 2>/dev/null || echo "")

            if validate_api_response "$pr_response" "PR"; then
              if command -v jq >/dev/null 2>&1; then
                pr_author_username=$(echo "$pr_response" | jq -r '.user.login // empty' 2>/dev/null || echo "")
              else
                pr_author_username=$(echo "$pr_response" | sed -n 's/.*"user"[^}]*"login"[^"]*"\([^"]*\)".*/\1/p' | head -1 || echo "")
              fi
            fi
          fi

          # Cache result to avoid duplicate requests
          PR_AUTHOR_CACHE["$pr_number"]="$pr_author_username"
          echo "$pr_author_username"
        }

        # Parse each commit
        COMMIT_COUNT=0
        while IFS="|" read -r hash subject author email; do
          [ -z "$hash" ] && continue
          
          COMMIT_COUNT=$((COMMIT_COUNT + 1))
          
          # Extract PR number if present (#123)
          PR_NUMBER=""
          if [[ "$subject" =~ $PR_PATTERN ]]; then
            PR_NUMBER="${BASH_REMATCH[1]}"
          fi
          
          # Extract conventional commit type and scope
          COMMIT_TYPE=""
          COMMIT_SCOPE=""
          COMMIT_MSG="$subject"
          
          if [[ "$subject" =~ $CONVENTIONAL_COMMIT_PATTERN ]]; then
            COMMIT_TYPE="${BASH_REMATCH[1]}"
            COMMIT_SCOPE="${BASH_REMATCH[3]}"
            # Remove type and scope from message
            COMMIT_MSG=$(echo "$subject" | sed -E 's/^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\([^)]+\))?: //')
          fi
          
          # Extract GitHub username and store contributor
          COMMIT_AUTHOR="$author"
          GITHUB_USERNAME_FOUND=""
          
          # Check GitHub email patterns first (no API needed)
          if [[ "$email" =~ $GITHUB_EMAIL_PATTERN ]]; then
            # Use GitHub username from email (no spaces)
            GITHUB_USERNAME="${BASH_REMATCH[1]}"
            GITHUB_USERNAME_FOUND="$GITHUB_USERNAME"
          elif [[ "$email" =~ $GITHUB_EMAIL_NUMERIC_PATTERN ]]; then
            # Handle numeric GitHub email format (e.g., 123456+username@users.noreply.github.com)
            GITHUB_USERNAME="${BASH_REMATCH[1]}"
            GITHUB_USERNAME_FOUND="$GITHUB_USERNAME"
          else
            # Try PR author first (more reliable for squash merges)
            if [ -n "$PR_NUMBER" ]; then
              GITHUB_USERNAME=$(get_pr_author_username "$PR_NUMBER")
              GITHUB_USERNAME_FOUND="$GITHUB_USERNAME"
            fi
            
            # Fall back to commit API if PR lookup failed
            if [ -z "$GITHUB_USERNAME_FOUND" ]; then
              GITHUB_USERNAME=$(get_github_username_from_commit "$hash" "$email" "$author")
              GITHUB_USERNAME_FOUND="$GITHUB_USERNAME"
            fi
          fi
          
          # Store contributor (simple logic without cleanup)
          if [ -n "$GITHUB_USERNAME_FOUND" ]; then
            COMMIT_AUTHOR="$GITHUB_USERNAME_FOUND"
            CONTRIBUTORS["$GITHUB_USERNAME_FOUND"]="github"
          else
            COMMIT_AUTHOR="$author"
            # Only store if we don't already have a GitHub username
            if [ -z "${CONTRIBUTORS[$author]+_}" ]; then
              CONTRIBUTORS["$author"]="name"
            fi
          fi
          
          # Format commit line
          SCOPE_TEXT=""
          if [ -n "$COMMIT_SCOPE" ]; then
            SCOPE_TEXT="**${COMMIT_SCOPE}**: "
          fi
          
          PR_TEXT=""
          if [ -n "$PR_NUMBER" ]; then
            PR_TEXT=" in [#${PR_NUMBER}](https://github.com/${{ github.repository }}/pull/${PR_NUMBER})"
          fi
          
          # Only use @ prefix for GitHub usernames
          if [ -n "$GITHUB_USERNAME_FOUND" ]; then
            COMMIT_LINE="- ${SCOPE_TEXT}${COMMIT_MSG} by @${COMMIT_AUTHOR}${PR_TEXT}"
          else
            COMMIT_LINE="- ${SCOPE_TEXT}${COMMIT_MSG} by ${COMMIT_AUTHOR}${PR_TEXT}"
          fi
          
          # Group by type
          case "$COMMIT_TYPE" in
            fix)
              FIXES+=("$COMMIT_LINE")
              ;;
            feat)
              FEATURES+=("$COMMIT_LINE")
              ;;
            docs)
              DOCS+=("$COMMIT_LINE")
              ;;
            refactor|perf)
              REFACTORS+=("$COMMIT_LINE")
              ;;
            style)
              STYLES+=("$COMMIT_LINE")
              ;;
            test)
              TESTS+=("$COMMIT_LINE")
              ;;
            chore|ci|build)
              CHORES+=("$COMMIT_LINE")
              ;;
            *)
              OTHERS+=("$COMMIT_LINE")
              ;;
          esac
        done <<< "$COMMITS"

        # ================================================================
        # 6. GENERATE RELEASE NOTES MARKDOWN
        # ================================================================

        # Start building release notes
        RELEASE_NOTES=""

        # Add What's Changed header
        RELEASE_NOTES+="## What's Changed"$'\n\n'

        # Add each section if it has commits
        if [ ${#FEATURES[@]} -gt 0 ]; then
          RELEASE_NOTES+="### âœ¨ Features"$'\n'
          for commit in "${FEATURES[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#FIXES[@]} -gt 0 ]; then
          RELEASE_NOTES+="### ðŸ› Bug Fixes"$'\n'
          for commit in "${FIXES[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#REFACTORS[@]} -gt 0 ]; then
          RELEASE_NOTES+="### â™»ï¸ Refactoring & Performance"$'\n'
          for commit in "${REFACTORS[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#DOCS[@]} -gt 0 ]; then
          RELEASE_NOTES+="### ðŸ“š Documentation"$'\n'
          for commit in "${DOCS[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#STYLES[@]} -gt 0 ]; then
          RELEASE_NOTES+="### ðŸŽ¨ Styling"$'\n'
          for commit in "${STYLES[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#TESTS[@]} -gt 0 ]; then
          RELEASE_NOTES+="### ðŸ§ª Testing"$'\n'
          for commit in "${TESTS[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#CHORES[@]} -gt 0 ]; then
          RELEASE_NOTES+="### ðŸ”§ Chores & CI"$'\n'
          for commit in "${CHORES[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        if [ ${#OTHERS[@]} -gt 0 ]; then
          RELEASE_NOTES+="### ðŸ“¦ Other Changes"$'\n'
          for commit in "${OTHERS[@]}"; do
            RELEASE_NOTES+="${commit}"$'\n'
          done
          RELEASE_NOTES+=$'\n'
        fi

        # Add full changelog link
        if [ "$PREV_TAG" != "NONE" ]; then
          RELEASE_NOTES+="**Full Changelog**: ${CHANGELOG_URL}"$'\n\n'
        else
          RELEASE_NOTES+="**Commits**: ${CHANGELOG_URL}"$'\n\n'
        fi

        # ================================================================
        # 6.5. DEDUPLICATE AND SORT CONTRIBUTORS
        # ================================================================

        # Note: Bash associative arrays already handle basic deduplication by key.
        # The improved detection logic above ensures GitHub usernames take precedence.

        # Sort contributors alphabetically (case-insensitive)
        SORTED_CONTRIBUTORS=($(
          for contributor in "${!CONTRIBUTORS[@]}"; do
            echo "$contributor"
          done | sort -f
        ))

        # Add contributors section with proper formatting
        if [ ${#CONTRIBUTORS[@]} -gt 0 ]; then
          RELEASE_NOTES+="## Contributors"$'\n\n'
          RELEASE_NOTES+="Thank you to everyone who contributed to this release:"$'\n\n'
          
          for contributor in "${SORTED_CONTRIBUTORS[@]}"; do
            CONTRIB_TYPE="${CONTRIBUTORS[$contributor]}"
            
            if [ "$CONTRIB_TYPE" = "github" ]; then
              # Link to GitHub profile for verified users
              RELEASE_NOTES+="- [@${contributor}](https://github.com/${contributor})"$'\n'
            else
              # Display name without link for non-GitHub contributors
              RELEASE_NOTES+="- ${contributor}"$'\n'
            fi
          done
          RELEASE_NOTES+=$'\n'
        fi

        # Add deployment metadata
        RELEASE_NOTES+="---"$'\n\n'
        RELEASE_NOTES+="## ðŸš€ Deployment Information"$'\n\n'
        RELEASE_NOTES+="- **Release Version**: \`${{ inputs.release-version }}\`"$'\n'
        RELEASE_NOTES+="- **Image Tag**: \`${{ inputs.image-tag }}\`"$'\n'
        RELEASE_NOTES+="- **Deployed**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"$'\n'

        if [ -n "${{ inputs.source-branch }}" ]; then
          RELEASE_NOTES+="- **Source Branch**: \`${{ inputs.source-branch }}\`"$'\n'
        fi

        # Save release notes to output (handle multiline)
        {
          echo 'release_notes<<EOF'
          echo "$RELEASE_NOTES"
          echo 'EOF'
        } >> $GITHUB_OUTPUT

        echo "âœ… Release notes generated successfully"
        echo ""
        echo "ðŸ“Š Summary:"
        echo "  - Total Commits Processed: ${COMMIT_COUNT}"
        echo "  - Features: ${#FEATURES[@]}"
        echo "  - Bug Fixes: ${#FIXES[@]}"
        echo "  - Refactoring: ${#REFACTORS[@]}"
        echo "  - Documentation: ${#DOCS[@]}"
        echo "  - Styling: ${#STYLES[@]}"
        echo "  - Tests: ${#TESTS[@]}"
        echo "  - Chores: ${#CHORES[@]}"
        echo "  - Others: ${#OTHERS[@]}"
        echo "  - Contributors: ${#CONTRIBUTORS[@]}"
